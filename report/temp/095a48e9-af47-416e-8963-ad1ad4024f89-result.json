{"name": "test_login[api_info0]", "status": "broken", "statusDetails": {"message": "TypeError: Session.request() got an unexpected keyword argument 'request_body'", "trace": "self = <test_login.TestLogin object at 0x000002B83F06E3B0>\napi_info = {'baseInfo': {'api_name': '登录接口', 'headers': '{\"Content-Type\": \"application/json\"}', 'method': 'POST', 'url': '/login'...request_body': {'password': '123456', 'username': 'admin'}, 'validation': [{'expected': 200, 'type': 'status_code'}]}]}\n\n    @pytest.mark.skipif(data is None, reason=\"login.yaml 读取失败，跳过测试\")\n    @pytest.mark.parametrize(\"api_info\", data if data else [{}])  # 避免 data=None 导致 TypeError\n    def test_login(self,api_info):\n        print(\"执行测试:\", api_info)\n        # 使用配置解析对象构造完整的 URL\n        config = ConfigParse()\n        full_url = config.get_host() + api_info['baseInfo'].get('url', '/post')\n    \n        # 复制测试用例数据，避免修改原始数据\n        test_data = dict(api_info['testCase'][0])\n        # 从测试数据中移除 case_name 并保存到变量 case_name\n        case_name = test_data.pop('case_name', '默认用例')\n        # 移除 validation（断言规则），避免重复传入\n        validation = test_data.pop('validation', None)\n    \n        # 处理 headers，如果 headers 是字符串，则转换为字典\n        headers = api_info['baseInfo'].get('headers', '{\"Content-Type\": \"application/json\"}')\n        if isinstance(headers, str):\n            headers = json.loads(headers)\n    \n        # 调用统一请求执行方法\n>       response = SendRequests().execute_api_request(\n            api_name=api_info['baseInfo'].get('api_name', '登录接口'),\n            url=full_url,\n            method=api_info['baseInfo'].get('method', 'POST'),\n            headers=headers,\n            case_name=case_name,\n            **test_data\n        )\n\ntestcases\\test_login.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nunit_tools\\apiutils_business\\SendRequests.py:32: in execute_api_request\n    response = self.send_request(url, method, headers, **kwargs, cookies=cookies, files=files)\nunit_tools\\apiutils_business\\SendRequests.py:14: in send_request\n    response = requests.request(method=method, url=url, headers=headers, data=data, cookies=cookies, files=files, timeout=10, verify=False, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmethod = 'POST', url = 'https://httpbin.org/login'\nkwargs = {'cookies': None, 'data': None, 'files': None, 'headers': {'Content-Type': 'application/json'}, ...}\nsession = <requests.sessions.Session object at 0x000002B83F0ECD90>\n\n    def request(method, url, **kwargs):\n        \"\"\"Constructs and sends a :class:`Request <Request>`.\n    \n        :param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary, list of tuples or bytes to send\n            in the query string for the :class:`Request`.\n        :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n            object to send in the body of the :class:`Request`.\n        :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n        :param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.\n            ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``\n            or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content_type'`` is a string\n            defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers\n            to add for the file.\n        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How many seconds to wait for the server to send data\n            before giving up, as a float, or a :ref:`(connect timeout, read\n            timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to ``True``.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n                the server's TLS certificate, or a string, in which case it must be a path\n                to a CA bundle to use. Defaults to ``True``.\n        :param stream: (optional) if ``False``, the response content will be immediately downloaded.\n        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n        :return: :class:`Response <Response>` object\n        :rtype: requests.Response\n    \n        Usage::\n    \n          >>> import requests\n          >>> req = requests.request('GET', 'https://httpbin.org/get')\n          >>> req\n          <Response [200]>\n        \"\"\"\n    \n        # By using the 'with' statement we are sure the session is closed, thus we\n        # avoid leaving sockets open which can trigger a ResourceWarning in some\n        # cases, and look like a memory leak in others.\n        with sessions.Session() as session:\n>           return session.request(method=method, url=url, **kwargs)\nE           TypeError: Session.request() got an unexpected keyword argument 'request_body'\n\nE:\\python\\lib\\site-packages\\requests\\api.py:59: TypeError"}, "attachments": [{"name": "log", "source": "2b35d219-28b1-4cbb-b96a-d96a61ec316f-attachment.txt", "type": "text/plain"}, {"name": "stdout", "source": "dbb46126-9e6a-44e5-a9f0-afa536ad3e02-attachment.txt", "type": "text/plain"}, {"name": "stderr", "source": "8f64ca50-1def-4051-af06-985d9cad11ac-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "api_info", "value": "{'baseInfo': {'url': '/login', 'method': 'POST', 'headers': '{\"Content-Type\": \"application/json\"}', 'api_name': '登录接口'}, 'testCase': [{'case_name': '正常登录', 'request_body': {'username': 'admin', 'password': '123456'}, 'validation': [{'type': 'status_code', 'expected': 200}]}]}"}], "start": 1742314307337, "stop": 1742314307345, "uuid": "e611cfec-baaf-4ed9-8a08-af214cc6c81b", "historyId": "e9b06027ff1e8c345871030c0851bee1", "testCaseId": "93a39feb8eb701231e6c069b76eeac98", "fullName": "testcases.test_login.TestLogin#test_login", "labels": [{"name": "tag", "value": "@pytest.mark.skipif(False, reason='login.yaml 读取失败，跳过测试')"}, {"name": "parentSuite", "value": "testcases"}, {"name": "suite", "value": "test_login"}, {"name": "subSuite", "value": "TestLogin"}, {"name": "host", "value": "DESKTOP-PRRMS83"}, {"name": "thread", "value": "21108-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "testcases.test_login"}]}